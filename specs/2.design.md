# aki-gsub Design Document

## 1. Introduction

This document outlines the software design for the `aki-gsub` command-line utility. The design is derived from its source code and is mapped to the acceptance criteria defined in `specs/1.acceptance-criteria.md`.

## 2. High-Level Architecture

`aki-gsub` is a standard Unix-style command-line tool that processes text streams. It is architected as a Rust library (`libaki_gsub`) with a thin executable wrapper (`main.rs`). This separation allows for clear distinction between the core logic and the application's entry point, making the core functionality easier to test and reuse.

The application follows a pipeline architecture:

1.  **Initialization**: The `main` function collects command-line arguments.
2.  **Configuration**: Arguments and environment variables are parsed into strongly-typed configuration structs.
3.  **Execution**: The core `run` logic reads from stdin, applies regex substitutions, and writes to stdout.
4.  **Termination**: The application exits with an appropriate status code.

## 3. Component Breakdown

The source code is organized into several modules, each with a distinct responsibility:

-   **`main.rs` (Executable Entry Point)**
    -   **Responsibility**: Handles the execution context of the command-line application.
    -   **Details**: It retrieves command-line arguments using `std::env::args()`, sets up the standard I/O streams using the `runnel` crate, invokes the library's main `execute` function, and handles any returned errors by printing them to stderr and exiting with a non-zero status code.

-   **`lib.rs` (Library Crate)**
    -   **Responsibility**: Acts as the public interface for the core logic.
    -   **Details**: It exposes `execute()` which takes the I/O streams and command-line arguments. It orchestrates the process by first parsing the configuration (`conf::parse_cmdopts`) and then passing the configuration to the core processing logic (`run::run`). This decouples argument parsing from the main substitution logic.

-   **`run.rs` (Core Logic)**
    -   **Responsibility**: Implements the primary text substitution functionality.
    -   **Details**: This is the heart of the application. It first compiles the string expressions from the configuration into `regex::Regex` objects. It then enters a loop, reading each line from the input stream. For each line, it finds all non-overlapping matches for every regex, stores them in a `Vec<ReplacedOut>`, sorts them by their start position, and reconstructs the output string by combining the non-matching parts with the formatted (and possibly colored) substitutions. This sorting step is critical for correctly handling multiple, overlapping patterns.

-   **`conf/` (Configuration Module)**
    -   **Responsibility**: Manages all application configuration.
    -   **Details**: This module uses the `flood-tide` crate for command-line parsing. `parse.rs` defines the argument structure and parsing logic. `cmd.match.rs.txt` and `cmd.help.rs.txt` are included as text to define the CLI options and help messages. It defines two key structs:
        -   `CmdOptConf`: Holds all options passed via command-line flags.
        -   `EnvConf`: Holds configuration from environment variables (for color sequences).

-   **`util/` (Utilities Module)**
    -   **Responsibility**: Provides shared, cross-cutting concerns.
    -   **Details**: Contains helper modules:
        -   `err.rs`: Implements a `BrokenPipeError` trait to detect and gracefully handle broken pipe I/O errors, preventing panics when output is piped to commands like `head`.
        -   `opt_color_when.rs`: Defines the `OptColorWhen` enum (`Always`, `Never`, `Auto`) and its parsing logic.
        -   `opt_uc_x_param.rs`: Defines the enum and parsing for the unstable `-X` options.

## 4. Data Flow

The data flows through the system as follows:

```
(CLI Arguments) --> main.rs
                     |
                     v
(Env Variables) --> lib.rs --(calls)--> conf::parse_cmdopts() --> (CmdOptConf, EnvConf)
                     |
                     v
(stdin) ----------> run::run() --(uses config)--> (regex processing) --> (stdout)
```

## 5. Key Data Structures

-   `CmdOptConf`: Stores the entire state of the command-line options (`Vec<String>` for expressions and formats, flags for quiet/help, etc.).
-   `RegexAndFormat`: A simple struct pairing a compiled `regex::Regex` object with its corresponding string format.
-   `ReplacedOut`: A temporary struct used in `run.rs` to store the start and end positions of a match and the resulting formatted output string.

## 6. Requirements Traceability

The design meets the acceptance criteria as follows:

-   **UC1, UC2, UC3, UC4, UC5 (Core Substitution)**: These are primarily fulfilled by the `run::run` function. It uses the `regex` crate for matching, iterates through all expression pairs, and reconstructs the output line, writing it to the standard output stream provided by `runnel`.
-   **EV1, EV2 (Help/Version)**: The `flood-tide` parser in `conf::parse_cmdopts` is configured to handle these flags. It returns specific errors that are identified in `lib.rs` to print the correct message and exit cleanly.
-   **OP1, OP2 (Color)**: The `run::run` function checks the `conf.opt_color` enum. If it's `Always`, it wraps substituted text with the color codes from `EnvConf`. The `Auto` logic is handled during the parsing phase in `conf::parse.rs`, where it checks if stdout is a TTY.
-   **OP3 (Quiet)**: In `run::run`, lines without matches are only printed if `!conf.flg_quiet` is true.
-   **OP4, OP5 (Env Vars)**: The `EnvConf::new()` function reads the `AKI_GSUB_COLOR_SEQ_ST` and `AKI_GSUB_COLOR_SEQ_ED` environment variables to override default color codes.
-   **ER1 (No Match)**: This is the default behavior in `run::run`, conditional on the `flg_quiet` flag.
-   **ER2, ER3 (Argument Errors)**: The `conf::parse_cmdopts` function contains validation logic that returns an error if arguments are missing or invalid (e.g., mismatched `-e`/`-f` counts). This error is propagated up to `main` for reporting.
-   **ER4 (Broken Pipe)**: The `run` function checks for this specific error using the `is_broken_pipe()` utility from `util::err` and returns `Ok(())` to allow for a graceful exit.
